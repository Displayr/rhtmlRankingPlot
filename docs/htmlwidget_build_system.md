
# HTML Widget Build Environment

## Overview

(At least some of the) HTML Widgets written by Numbers International are maintained as ES2015 (aka ES6) based nodejs projects that use gulp as a task manager. The twofold purpose(s) of these nodejs projects is to produce R HTMLWidget packages, and provide a framework for developing and testing the R htmlwidget pacakges. The [rhtmlTemplate](https://github.com/NumbersInternational/rhtmlTemplate) and [rhtmlPictographs](https://github.com/NumbersInternational/rhtmlPictographs) repositories are examples.

This document starts by listing the gulp `tasks` and why you would use them, then outlines the project structure and the purpose of each file. If this is all new to you you may want to start by jumping ahead to the `Terminology/Technology Breakdown` section, and then come back to the `gulp tasks` and `project structure` sections.

I will once again list the two most important things to remember:

1. The last thing you do before committing is run `gulp build` to ensure all the autogenerated files are up to date.
2. (With some exceptions) **ONLY EDIT THINGS IN these directories: `theSrc`, `docs` !!** Many of the other files are auto generated based on the contents of `theSrc`. As an example, if you edit `R/rhtmlTemplate.R` and then run `gulp build` your changes will be DELETED FOREVER!, because `R/rhtmlTemplate.R` is just a copy of `theSrc/R/htmlwidget.R`.

## Gulp Tasks

`gulp build` : simply by running `gulp build` the following tasks are performed :
 - delete the directories that contain auto generated code
 - run the test suite and fail the build if the tests fail
 - bundle all the Javascript - including dependencies - into a single file, and transpile the ES6 into ES5 javascript while creating the bundled file
 - compile the LESS into CSS and place in the dist directories
 - copy all images and other resources into the dist directories
 - generate the R docs from the R files and place into the man/ directory

`gulp serve` : simply by running `gulp serve` the following tasks are performed :
 - all of the build tasks above (except make docs and make R examples)
 - also produce a different transpiled version of the code that will load in a local browser window
 - in addition to the HTML Widget libraries, the local browser session will include a list of examples. This allows the developer to view how the effect of their most recent changes
 - gulp serve also starts a `watch` process. When used correctly this has a major impact on development velocity. Every save to the local file system will rebuild the project and then send a signal to the browser to reload the active page, so that the changes just made to the project are immediately visible.

### Why gulp serve ?

After reading the `gulp serve` description above, consider the following scenario where I begin to add feature X to my widget. I add an example called _**feature X WIP**_ to the [internal_www content](/theSrc/internal_www/content) area (see details [here](./visual_regression_testing_and_the_internal_www_server.md)). I run `gulp serve`, and navigate to the _**feature X WIP**_ example. It doesn't work :(. This makes sense though because I haven't even written the code yet ! I make a series of changes to implement feature X, and I have a big monitor/two monitors so I have my browser and my IDE visible at the same time. Every time I save an update to my project files, gulp auto builds the code, and sends a reload signal to my browser. I am literally seeing the visual effects of my code changes in real time. _**This is really good**_.

## Project Structure

First a primer on R packages, specifically R htmlwidget packages. More detailed info can be found on the html widgets develop instro site : [http://www.htmlwidgets.orghttp://www.htmlwidgets.org/develop_intro.html](http://www.htmlwidgets.org/develop_intro.html). The following is a breakdown of the minimum set of files to create a HTMLWidget called Foo.

* **LICENSE** - License file
* **DESCRIPTION** - a R package manifest containing package name, version, author, etc.
* **NAMESPACE** - R import and export declarations
* **R/FOO.R** - the R code that defines the R API for the HTMLWidget
* **inst/htmlwidgets/FOO.js** - the javascript definition of the html widget
* **inst/htmlwidgets/FOO.yaml** - a manifest file that defines the javascript and css dependencies of the htmlwidget
* **inst/htmlwidgets/lib/DEPENDENCY.js** - a JS dependency, think jquery or d3. These must be listed in the YAML file.
* **inst/htmlwidgets/lib/STYLE.css** - CSS dependency

Given we use npm and package.json to manage our dependencies, and given we have a browser/ directory that supports the `gulp serve` workflow, maintaining our code in the structure outlined above is not really a good option. Instead, we choose to maintain all the source code in a directory called `theSrc` and use a gulp build process to automatically generate the R htmlwidget file structure above from the source in `theSrc`.

Even though the original/gold/working/active copy of all the src is in a folder called `theSrc`, we still check all the `compiled` versions in inst into github. Why? One of the displayr project requirements is that all R packages, including HTML Widgets, must be installable via a single `devtools::install_github` command. This means that all of outputs of the build process must be checked in to git.

_**So lets recap a really important point: only edit files in the `theSrc`, and `docs` directories.**_. All files in the `R/`, `inst/`, and `man/` directories are autogenerated by the `gulp build` / `gulp serve` task using input from the `theSrc` directory. If you edit in `inst` and then run `gulp build` it will wipe out all your hard work, and your colleagues will laugh at your misfortune !

## Other Files and Their Roles

There are lots of files. This is what they do:

**Build files**
* **package.json** - this lists all of the npm dependencies. When the project is initially checked out from git, the first thing a developer does is run `npm install`. The `npm install` command reads the `package.json` file and locally installs all of the specified dependencies into the `node_modules` directory.
* **gulpfile.js** - this defines and implements the build tasks. Any task can be defined and arbitrarily named. In htmlwidget projects the two main tasks are `serve` and `build`. The gulpfile uses `tasks`, `scripts`, and `configs`, all of which are located in the [build](/build) directory
* **build/config/externalLibs.js** - this is an array of all the 3rd party javascript the widget relies on. It is used by the gulpfile and by the tests.
* **build/config/karma.conf.js** - this is the config file for the Karma test runner. Some file lists here will need to be kept up to date by the developer.
* **build/config/protractor.conf.js** - this is the config file for the protractor test runner. Some file lists here will need to be kept up to date by the developer.
* **build/config/testVisual.json** - this contains some config parameters for applitools browser snapshotting tool.
* **build/config/widget.config.json** - this contains the name of the widget and needs to be updated in new projects.
* **build/scripts/buildContentManifest.js** - utility that (in conjunction with `build/tasks/buildContentManifest.js`) scans the [internal_www](/theSrc/internal_www/content) area writes a list of the content files to this file: `browser/content/contentManifest.json`
* **build/scripts/convertContentToExamplesInR.js** - generate R function signatures for every example in the [internal_www](/theSrc/internal_www/content) area, and save these R signatures in the [examples](/examples) area.
* **build/scripts/makeDoc.r** - utility to generate the R docs via roxygen
* **build/scripts/testVisual.r** - script to programatically generate test cases from the content in [internal_www](/theSrc/internal_www/content) and take [applitools](https://applitools.com/) snapshots for visual regression testing 
* **build/tasks/** - Each file in the tasks directory defines a [gulp](http://gulpjs.com/) task

**Auto Generated files**
* **browser/** - this content is **autogenerated** and is used to test and develop the htmlwidget in a chrome browser context - this is done when running gulp serve.
* **inst/** - this is **autogenerated** and is a required directory where the HTML widget framework will look for all its JS resources
* **man** - this is **autogenerated** and contains R docs
* **R** - this is **autogenerated** and contains the R function signature for the html widget
* **examples/ - this is **autogenerated** and contains R code examples showing intended use of the htmlwidget

**Internal WWW files**
* **theSrc/internal_www/index.html** - the html entry point that is displayed when you browse to http://localhost:9000/. This lists all of the content in the content directory.
* **theSrc/internal_www/content** - this area contains all of the examples that are hosted on the internal_www server.
* **theSrc/internal_www/experiments** - just a html scratch space.
* **theSrc/internal_www/js/renderIndexPage.js** - this script renders the index page using the `contentManifest` file.
* **theSrc/internal_www/js/renderContentPage.js** - this script interprets a html file in the content area and calls the widget code to convert the configs into rendered widgets.
* **theSrc/internal_www/styles/internal_www.css** - this script interprets a html file in the content area and calls the widget code to convert the configs into rendered widgets.

**Src Files**
* **theSrc/scripts/** - This is your ES6 source. This is what you change. There are more notes on the source code in the [how the code works](./how_the_code_works.md) docs
* **theSrc/images** - put your images here, you can use them in the browser but at present we dont know how to package images in htmlwidgets !
* **theSrc/visualRegression** - if you have visual regression tests that require interaction before taking a snapshot, put the test setup scripts here
* **theSrc/R/htmlwidget.R** - this is copied to R/WIDGETNAME.R and contains the R function definitions used to invoke your widget. _**You do not need to rename this file.**_
* **theSrc/R/htmlwidget.yaml** - this is copied to inst/htmlwidget/WIDGETNAME.yaml and contains a manifest the htmlwidget framework uses. See [http://www.htmlwidgets.orghttp://www.htmlwidgets.org/develop_intro.html](http://www.htmlwidgets.org/develop_intro.html) for details. _**You do not need to rename this file.**_. You will have to update it to match the js files and dependencies you add.
* **theSrc/styles/main.less** - this is your CSS in a less file. It is used to generate `inst/htmlwidgets/lib/style/main.css`

**Test Files**
* **build/config/karma.conf.js** - This file defines the test configuration used by Karma to execute your unit tests
* **theSrc/scripts/*.spec.js** - These are karma test files. See [https://karma-runner.github.io/](https://karma-runner.github.io/) for docs on how to write tests using Karma.
* **build/config/protractor.conf.js** - This file defines the test configuration used by [Protractor](http://www.protractortest.org/) to execute the visual regression tests
* **build/config/protractor.conf.js** - This file defines the test configuration used by [Protractor](http://www.protractortest.org/) to execute the visual regression tests
* **build/scripts/testVisual.r** - script to programatically generate test cases from the content in [internal_www](/theSrc/internal_www/content) and take [applitools](https://applitools.com/) snapshots for visual regression testing

## Terminology/Technology Breakdown

What does the above really mean ?

**Node project** : Fundamentally all this means is two things:

1. the project contains nodejs code (which is just javascript run on the "server" not in the "browser")
1. there is a package.json file at the project root, and that package.json file defines all of the nodejs and browser javascript that is required for the project.

Once a git repo has a package.json, then anyone who clones the repo onto their local machine can download all of the project dependencies simply by running `npm install`. This of course assumes that node and npm are already installed.

**Transpile ??** : Compiling is generally understood to be converting a higher level of abstraction into a lower one, for example taking C++ and producing X86 assembly code. Transpiling is converting to/from languages of equal levels of abstraction, for example coffeescript to ES5 javascript, or ES6 javascript to ES5 javascript. This is necessary because modern web browsers still do not have consistent 100% support for ES6 (aka ES2015) javascript. At present, if you want your javascript to work in a good percentage of your customers' browsers, then you need to produce ES5. The problem is that ES5 is missing a LOT of modern language features and makes developers sad.

**HTML Widget Packages**: A R HTML Widget is a special type of R package that contains R code, as well as Javascript. In the case of most HTML Widgets (warning arbitrary stat) 95%  of the code is Javascript and there is very little R code. The majority of our 3rd party dependencies are Javascript packages, so it makes sense to adopt a dependency management system and best practices from the nodejs community (i.e., npm packaging and gulp build tool). However, the end product is still R code. We need a way to use npm to dynamically pull all our dependencies, but still produce a compliant R HTMLWidget package, enter the ....

**Gulp Build System**: Gulp is one of several nodejs based task managers that provide standard ways to define multi step development tasks such as code packaging, code testing, code compiling, and many other common tasks. It's kind of like `make` . Alternatives exist such as grunt and webpack; we are using gulp. Gulp is easiest understood by providing examples, which are provided in the next section.

## Why `theSrc` instead of `src`

I think that R treats all the code in `src` as C/C++ code and compiles it when you run a `devtools::install()`. This only happens on Windows. In any case, best not call your src folder `src` unless you want trouble.

## I'm totally sold! How do I make my htmlwidget use this system ?

Excellent, it would be great if we had a yeoman style project template, but in the absense of that, follow the instructions in [exending the template](./extending_the_template.md).
